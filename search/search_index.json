{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome","title":"Welcome","text":"<p>I'm Josh, and this is my technical blog dedicated to topics related mostly to software development, including:</p> <ul> <li>PowerShell modules, scripts, and tips</li> <li>Automation / DevOps</li> <li>.NET / C#</li> <li>Milestone XProtect VMS software &amp; integrations</li> <li>Home lab shenanigans involving reverse proxies, identity systems, and containers</li> </ul>"},{"location":"#about-me","title":"About me","text":"<p>I'm currently a senior principal engineer at Milestone Systems where I've enjoyed a variety of roles and experiences since 2006. A few years ago I transitioned out of a principal role in the technical support team into a full-time floating role half way between firefighting technical support and professional services escalations, and software development. As of the start of 2024 I am a full time software developer working with a mix of PowerShell, .NET, and things that might be considered DevOps but I just call being a well rounded software engineer.</p> <p>A sizable chunk of my time goes toward maintaining and supporting the MilestonePSTools PowerShell module I started building in 2019, and it's my favorite project to work on. It enables Milestone XProtect customers to automate configuration, reporting, export tasks, and more on their video surveillance systems, and it's used by customers at every scale from small businesses with a handful of cameras to government agencies and giant global data centers.</p> <p>I began learning PowerShell in 2019 as a part of the process of building MilestonePSTools, and I fell it love with it as a shell, as a language, and especially as a community. I have been attending the PowerShell + DevOps Global Summit in Bellevue, WA since 2021, and I can't recommend it highly enough. The insight shared during (and between) sessions is inspiring, and the community is diverse and welcoming.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2023/09/06/debugging-convertto-json/","title":"Debugging ConvertTo-Json","text":"<p>My co-worker, Jared, who regularly uses MilestonePSTools and builds tools with it brought me an interesting problem yesterday - an apparent compatibility issue between our SDK and the <code>ConvertTo-Json</code> cmdlet from the built-in Microsoft.PowerShell.Utility module. If you've ever struggled with the error \"ConvertTo-Json : An item with the same key has already been added.\", follow along as I share our debugging process until we finally discovered the root cause. While the details in this post involve the Milestone SDK and the MilestonePSTools module, the root cause and the process of finding it is relevant to anyone using .NET assemblies or 3rd party modules with PowerShell.</p>"},{"location":"blog/2023/09/06/debugging-convertto-json/#the-problem","title":"The problem","text":"<p>Jared built a fairly comprehensive tool to assist with migrating the configuration from one Milestone site to another. The tool gathers all the camera settings, groups, roles, views, and more, exports it mostly to JSON, and then allows for importing that collection of JSON files into another Milestone site for the purpose of consolidating many small systems into one or more larger systems.</p> <p>The tool is essentially complete, and Jared was updating to the latest release of MilestonePSTools and MipSdkRedist to verify that everything still worked with the most recent releases, and that's when he discovered it now failed with the error \"ConvertTo-Json : An item with the same key has already been added.\"</p>"},{"location":"blog/2023/09/06/debugging-convertto-json/#initial-questions","title":"Initial questions","text":"<p>The first thing Jared did was change nothing, other than to explicitly import an older version of MilestonePSTools where the problem was known not to exist. This is a great first step to answer the question \"is this a problem with the PowerShell module, or the state of the test VMS it is connected to?\"</p> <p>Surprisingly, after importing an older version of MilestonePSTools in a fresh new PowerShell terminal, the problem persisted. This was unexpected.</p> <p>After running <code>Get-Module</code> to list the imported modules, he could see that the desired version of MilestonePSTools was imported, but that the latest version of the SDK was being imported instead of the older version of the SDK. This is because MilestonePSTools only requires that MipSdkRedist is at least version x.y.z. By default, PowerShell imported the most recent version available.</p> <p>The next step was to explicitly import the older version of MipSdkRedist, and then import the older version of MilestonePSTools. At this point, he got the expected result - everything worked correctly.</p> <p>By this stage, Jared had narrowed the issue down to the latest release of MipSdkRedist since the known-good version of MilestonePSTools failed when using the latest MipSdkRedist release, and succeeded when using the older MipSdkRedist release. The last thing he did before reaching out to me was check to see whether the depth mattered, so he tried a depth of 1 and a depth of 100 and they both failed when using the latest MipSdkRedist module version.</p>"},{"location":"blog/2023/09/06/debugging-convertto-json/#is-this-a-bug","title":"Is this a bug?","text":"<p>It was at this point that Jared pinged me on Teams to let me know he might have found a bug in the MIP SDK. The MIP SDK is a dependency of MilestonePSTools that is maintained by a team in Denmark that we talk to regularly. But it isn't their responsibility to debug Microsoft's <code>ConvertTo-Json</code> cmdlet to figure out why it doesn't like some of the objects in our SDK, so we wanted to understand exactly why <code>ConvertTo-Json</code> was throwing this error.</p> <p>One of the first things we did was to search for similar reports online. Unfortunately we found several, and the comments weren't any better than the error message itself.</p> <p>The error \"An item with the same key has already been added\" is a well-known error to a .NET / C# developer and it happens when you try to add the same key to a dictionary twice. For example...</p> <pre><code>$dictionary = [collections.generic.dictionary[[string], [string]]]::new()\n$dictionary.Add('TestKey', 'TestValue')\n$dictionary.Add('TestKey', 'TestValue')\n</code></pre> <p>If you run that, you'll get the error <code>Exception calling \"Add\" with \"2\" argument(s): \"An item with the same key has already been added.\"</code>.</p> <p>But how exactly is <code>ConvertTo-Json</code> finding two properties with the same name on an object? When we use <code>Format-List</code> and <code>Get-Member</code> to inspect the properties of the offending object, each property is unique as expected. So is this a bug in the Milestone SDK, or is it a bug in <code>ConvertTo-Json</code>?</p>"},{"location":"blog/2023/09/06/debugging-convertto-json/#select-object","title":"Select-Object","text":"<p>We were working with a Role object, though later we would discover the issue applies to all configuration api objects. Anyway, on a whim I ran <code>$role | Select-Object * | ConvertTo-Json</code> and it worked normally. So there was definitely something hinky about the Role type.</p>"},{"location":"blog/2023/09/06/debugging-convertto-json/#expanding-the-error","title":"Expanding the error","text":"<p>Every error you see in PowerShell is added to the top of the automatic <code>$Error</code> variable which is an object of type <code>[System.Collections.ArrayList]</code> containing a collection of <code>[System.Management.Automation.ErrorRecord]</code> objects. You will often discover more detailed information by looking closer at these using <code>Format-List * -Force</code>, and by expanding the Exception and InnerException properties which can sometimes be nested several layers deep.</p> <p>Here's what I found...</p> <pre><code>$error[0] | Format-List -Force\n&lt;#\nException             : System.ArgumentException: An item with the same key has already been added.\n                           at System.ThrowHelper.ThrowArgumentException(ExceptionResource resource)\n                           at System.Collections.Generic.Dictionary`2.Insert(TKey key, TValue value, Boolean add)\n                           at Microsoft.PowerShell.Commands.ConvertToJsonCommand.ProcessCustomObject[T](Object o, Int32 depth)\n                           at Microsoft.PowerShell.Commands.ConvertToJsonCommand.ProcessValue(Object obj, Int32 depth)\n                           at Microsoft.PowerShell.Commands.ConvertToJsonCommand.EndProcessing()\n                           at System.Management.Automation.CommandProcessorBase.Complete()\nTargetObject          :\nCategoryInfo          : NotSpecified: (:) [ConvertTo-Json], ArgumentException\nFullyQualifiedErrorId : System.ArgumentException,Microsoft.PowerShell.Commands.ConvertToJsonCommand\nErrorDetails          :\nInvocationInfo        : System.Management.Automation.InvocationInfo\nScriptStackTrace      : at &lt;ScriptBlock&gt;, &lt;No file&gt;: line 1\nPipelineIterationInfo : {}\nPSMessageDetails      :\n#&gt;\n$error[0].Exception | Format-List -Force\n&lt;#\nMessage        : An item with the same key has already been added.\nParamName      :\nData           : {}\nInnerException :\nTargetSite     : Void ThrowArgumentException(System.ExceptionResource)\nStackTrace     :    at System.ThrowHelper.ThrowArgumentException(ExceptionResource resource)\n                    at System.Collections.Generic.Dictionary`2.Insert(TKey key, TValue value, Boolean add)\n                    at Microsoft.PowerShell.Commands.ConvertToJsonCommand.ProcessCustomObject[T](Object o, Int32 depth)\n                    at Microsoft.PowerShell.Commands.ConvertToJsonCommand.ProcessValue(Object obj, Int32 depth)\n                    at Microsoft.PowerShell.Commands.ConvertToJsonCommand.EndProcessing()\n                    at System.Management.Automation.CommandProcessorBase.Complete()\nHelpLink       :\nSource         : mscorlib\nHResult        : -2147024809\n#&gt;\n</code></pre> <p>Unfortunately I didn't learn much about why the exception was being thrown from digging into the error this time, but the stack trace would be useful in the next step.</p>"},{"location":"blog/2023/09/06/debugging-convertto-json/#time-to-decompile","title":"Time to decompile","text":"<p>I was running out of ideas and needed to see the implementation of <code>ConvertTo-Json</code> to understand how the cmdlet was finding two identical properties on my objects and what they were. By inspecting the error and referencing the stack trace, I knew that the <code>Microsoft.PowerShell.Commands.ConvertToJsonCommand.ProcessCustomObject[T](Object o, Int32 depth)</code> method is where a duplicate key was being added to a dictionary, so I checked the open-source version of PowerShell (PowerShell 7) on GitHub, but the implementation of <code>ConvertTo-Json</code> was too different from the PowerShell 5.1 version to be useful - it didn't have a ProcessCustomObject method.</p> <p>The source code for PowerShell 5.1 is not publicly available, so I had to resort to using a decompiler tool like DotPeek from JetBrains or JustDecompile from Telerik. Software and libraries written in C# or any other .NET language are compiled into CIL or \"common intermediate language\", or IL for short, which is governed by an open standard. Decompilers can look at a .EXE or .DLL file and interpret the IL, then produce a version of the what the original source code might look like. It's not perfect, and sometimes organizations use tools to obfuscate the compiled assemblies rendering them harder for a human to interpret, but most of the time you can get a good look at the source code and this was no exception.</p> <p>I won't share any screenshots or snippets of the source code for the <code>ConvertTo-Json</code> function as I don't want to risk any legal issues related to \"reverse engineering\" or releasing intellectual property. But here's what I found and how I found it...</p>"},{"location":"blog/2023/09/06/debugging-convertto-json/#finding-the-right-dll","title":"Finding the right DLL","text":"<p>To get a look at the source code, I needed to track down the assembly containing the definition for the <code>ConvertTo-Json</code> cmdlet. So I started with <code>Get-Command ConvertTo-Json | Format-List *</code> which returned the following. The highlighted line showing the path to the DLL is exactly what I needed.</p> <pre><code>HelpUri             : https://go.microsoft.com/fwlink/?LinkID=217032\nDLL                 : C:\\WINDOWS\\Microsoft.Net\\assembly\\GAC_MSIL\\Microsoft.PowerShell.Commands.Utility\\v4.0_3.0.0.0__31bf3856ad364e35\\Microsoft.PowerShell.Commands.Utility.dll\nVerb                : ConvertTo\nNoun                : Json\nHelpFile            : Microsoft.PowerShell.Commands.Utility.dll-Help.xml\nPSSnapIn            :\nVersion             : 3.1.0.0\nImplementingType    : Microsoft.PowerShell.Commands.ConvertToJsonCommand\nDefinition          :\n                      ConvertTo-Json [-InputObject] &lt;Object&gt; [-Depth &lt;int&gt;] [-Compress] [&lt;CommonParameters&gt;]\n\nDefaultParameterSet :\nOutputType          : {}\nOptions             : ReadOnly\nName                : ConvertTo-Json\nCommandType         : Cmdlet\nSource              : Microsoft.PowerShell.Utility\nVisibility          : Public\nModuleName          : Microsoft.PowerShell.Utility\nModule              : Microsoft.PowerShell.Utility\nRemotingCapability  : None\nParameters          : {[InputObject, System.Management.Automation.ParameterMetadata], [Depth, System.Management.Automation.ParameterMetadata], [Compress, System.Management.Automation.ParameterMetadata],\n                      [Verbose, System.Management.Automation.ParameterMetadata]...}\nParameterSets       : {[-InputObject] &lt;Object&gt; [-Depth &lt;int&gt;] [-Compress] [&lt;CommonParameters&gt;]}\n</code></pre>"},{"location":"blog/2023/09/06/debugging-convertto-json/#what-exactly-is-processcustomobject-doing","title":"What exactly is ProcessCustomObject doing?","text":"<p>Finally, using my favorite decompiler, I opened the DLL containing the <code>ConvertTo-Json</code> definition, and found the <code>ProcessCustomObject</code> method inside the class <code>Microsoft.PowerShell.Commands.ConvertToJsonCommand</code>. Inside the method, I could see that the fields and properties on the objects passed in were being discovered using <code>type.GetProperties(BindingFlags.Instance | BindingFlags.Public)</code>, so I wrote the same thing in PowerShell and retrieved the names and types of all the properties returned on a Role object. Check out the highlighted lines:</p> <pre><code>$type = (Get-VmsRole | Select-Object -First 1).GetType()\n$properties = $type.GetProperties(([system.reflection.bindingflags]::Instance -bor [system.reflection.bindingflags]::Public))\n$properties | Select-Object Name, PropertyType | Sort-Object Name\n&lt;#\nName                               PropertyType\n----                               ------------\nAllowMobileClientLogOn             System.Boolean\nAllowSmartClientLogOn              System.Boolean\nAllowWebClientLogOn                System.Boolean\nClaimFolder                        VideoOS.Platform.ConfigurationItems.ClaimFolder\nClientProfile                      System.String\nDescription                        System.String\nDisplayName                        System.String\nDualAuthorizationRequired          System.Boolean\nId                                 System.Guid\nId                                 System.String\nItemCategory                       System.String\nLastModified                       System.DateTime\nMakeUsersAnonymousDuringPTZSession System.Boolean\nMethods                            System.Collections.ObjectModel.Collection`1[System.String]\nName                               System.String\nParentItemPath                     System.String\nParentPath                         System.String\nPath                               System.String\nRoleClientLogOnTimeProfile         System.String\nRoleDefaultTimeProfile             System.String\nRoleType                           System.String\nRoleTypeValues                     System.Collections.Generic.Dictionary`2[System.String,System.String]\nServerId                           VideoOS.Platform.ServerId\nUserFolder                         VideoOS.Platform.ConfigurationItems.UserFolder\n#&gt;\n</code></pre> <p>So <code>ConvertTo-Json</code> is using reflection to inspect the objects to be serialized to JSON, and it's finding two different \"Id\" properties on the Role object - one of type <code>[string]</code> and one of type <code>[guid]</code>!</p> <p>Now that I knew which property was causing the problem, I could take a closer look at those specific properties...</p> <pre><code>$type = (Get-VmsRole | Select-Object -First 1).GetType()\n$properties = $type.GetProperties(([system.reflection.bindingflags]::Instance -bor [system.reflection.bindingflags]::Public)) | Where-Object Name -eq 'Id'\n$properties | Format-List * -Force\n&lt;#\nMemberType       : Property\nName             : Id\nDeclaringType    : VideoOS.Platform.ConfigurationItems.Role\nReflectedType    : VideoOS.Platform.ConfigurationItems.Role\nMetadataToken    : 385879854\nModule           : VideoOS.Platform.dll\nPropertyType     : System.String\nAttributes       : None\nCanRead          : True\nCanWrite         : False\nGetMethod        : System.String get_Id()\nSetMethod        :\nIsSpecialName    : False\nCustomAttributes : {[System.Diagnostics.CodeAnalysis.SuppressMessageAttribute(\"Microsoft.Naming\", \"CA1704:IdentifiersShouldBeSpelledCorrectly\")]}\nMemberType       : Property\nName             : Id\nDeclaringType    : VideoOS.Platform.ConfigurationItems.IConfigurationItem\nReflectedType    : VideoOS.Platform.ConfigurationItems.Role\nMetadataToken    : 385879365\nModule           : VideoOS.Platform.dll\nPropertyType     : System.Guid\nAttributes       : None\nCanRead          : True\nCanWrite         : False\nGetMethod        : System.Guid get_Id()\nSetMethod        :\nIsSpecialName    : False\nCustomAttributes : {}\n#&gt;\n</code></pre> <p>Looking at the <code>DeclaringType</code> property, I could see that the Id property of type <code>[string]</code> that I'm used to is declared on the Role type directly. However, the new <code>[guid]</code> Id property is defined on the IConfigurationItem type inherited from by the Role type. And indeed, looking at the source code for the SDK, that Id property was recently added for one reason or another and I'm now checking with the SDK team to understand why, and whether it is possible to safely change the implementation since it is a relatively new and apparently breaking change in rare circumstances.</p>"},{"location":"blog/2023/09/06/debugging-convertto-json/#what-next","title":"What next?","text":"<p>In our case, we can work around this duplicate Id property if needed by using <code>Select-Object</code> to filter for the properties we want, or even use <code>Select-Object *</code> which generates a new type on the fly with all the visible properties of the incoming object.</p> <p>I think the \"right way\" to resolve the issue is to make it so that the Id properties on both the IConfigurationItem and the various types that inherit from it are both of type <code>[string]</code> and then override the Id property on child types rather than declare another Id property which effectively \"hides\" the parent types version of the property except when using reflection.</p> <p>Reflection is the primary language tool in .NET for building serializers for converting objects to and from JSON, XML, and other formats, and using the override key word should hopefully make it so that the only Id property available to <code>ConvertTo-Json</code> and other serializers is the one on the objects where the property is overridden.</p>"},{"location":"blog/2023/09/09/using-custom-attributes-in-powershell/","title":"Using custom attributes in PowerShell","text":""},{"location":"blog/2023/09/09/using-custom-attributes-in-powershell/#introduction","title":"Introduction","text":"<p>I've been working with with custom attributes in PowerShell for the last few months and they can be incredibly useful in the right circumstances. You know those handy built-in argument validators like <code>[ValidateRange(1, 10)]</code>, <code>[ValidateSet('Apples', 'Oranges')]</code>, or <code>[ValidateNotNullOrEmpty()]</code> that you get for free? You can make your own custom versions, and it can really level up your module quality and even improve your documentation. Let's start with what they are, and how they work.</p>"},{"location":"blog/2023/09/09/using-custom-attributes-in-powershell/#what-are-attributes","title":"What are attributes?","text":"<p>Attributes are a feature of many languages which allow the developer to attach extra information to an object. These attributes are available at runtime using another language feature called \"reflection\" which enables an application to inspect itself while it's running. You've probably encountered these in PowerShell if you've ever seen or written a cmdlet or advanced function. For example, <code>[CmdletBinding()]</code>, <code>[Parameter()]</code>, and <code>[ValidateNotNullOrEmpty()]</code> are all attributes which help the PowerShell runtime find your commands, and bind or validate parameters when those commands are used.</p> <p>An attribute can have its own positional, or named parameters, and those properties can be used in different ways. For instance, when you add an attribute like <code>[ValidateSet('Option1', 'Option2')]</code> to a parameter in a PowerShell function, the PowerShell runtime uses that information during parameter binding when that function is called. If the value for the parameter isn't either \"Option1\" or \"Option2\", the PowerShell runtime will throw a <code>ParameterBindingValidationException</code> exception with a really informative error message like...</p> <pre><code>Cannot validate argument on parameter 'YourParameterName'. The argument \"Option3\" does not belong\nto the set \"Option1,Option2\" specified by the ValidateSet attribute. Supply an argument that is in the set\nand then try the command again.\n</code></pre> <p>Adding a little extra information to your code using attributes allows PowerShell to enhance the user experience for anyone using your scripts, modules, tools, etc. And they aren't just used to add easy parameter validation and clear error messages. They can also be used to automatically generate or augment documentation. For instance, if you use <code>[ValidateSet()]</code>, in the commands within a PowerShell module, the platyps module will discover the valid values and include them in your docs automatically!</p>"},{"location":"blog/2023/09/09/using-custom-attributes-in-powershell/#argument-validation","title":"Argument validation","text":""},{"location":"blog/2023/09/09/using-custom-attributes-in-powershell/#with-validatescript","title":"with ValidateScript","text":"<p>Before I talk about the <code>ValidateArgumentsAttribute</code> base class and other uses for custom attributes in PowerShell, I should introduce the [ValidateScript()] attribute. This is a super flexible argument validation attribute you can use right out of the box to perform any kind of validation you want on an argument. For instance, what if you have a function with a parameter named \"LuckyNumber\" which needs to be an integer greater than 0, and only divisible by 7?</p> <p>There are three constraints:</p> <ol> <li>The type must be <code>[int]</code></li> <li>The range is 0 to <code>[int]::MaxValue</code> or 2147483647</li> <li>The value must be divisible by 7</li> </ol> <p>The first two are easy enough to check using <code>[ValidateRange()]</code> and specifying the <code>[int]</code> type when declaring the function parameter, but [ValidateDivisibleBy(7)] isn't a thing. You'll need to write your own code somewhere to validate divisibility of values passed to the LuckyNumber parameter. I imagine most of the time people would choose to inspect the value toward the top of the begin, or process blocks of the function. But you could also do this with the <code>[ValidateScript()]</code> attribute. Here's what both options, and their validation errors might look like:</p> Without ValidateScriptWith ValidateScript <pre><code>function Do-Something {\n[CmdletBinding()]\nparam(\n[Parameter()]\n[ValidateRange(0, [int]::MaxValue)]\n[int]\n$LuckyNumber\n)\nprocess {\n# We only know LuckyNumber is an integer &gt;= 0 so we need to test it before we continue.\nif ($LuckyNumber % 7) {\nthrow \"The number $LuckyNumber is not divisible by 7.\"\n}\n$LuckyNumber\n}\n}\nDo-Something -LuckyNumber 13\n&lt;# OUTPUT\n    The number 13 is not divisible by 7.\n    At line:13 char:17\n    + ...                throw \"The number $LuckyNumber is not divisible by 7.\"\n    +                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n        + CategoryInfo          : OperationStopped: (The number 13 is not divisible by 7.:String) [], RuntimeExcepti\n    on\n        + FullyQualifiedErrorId : The number 13 is not divisible by 7.\n#&gt;\n</code></pre> <pre><code>function Do-Something {\n[CmdletBinding()]\nparam(\n[Parameter()]\n[ValidateRange(0, [int]::MaxValue)]\n[ValidateScript({\nif ($_ % 7) {\nthrow \"The number $_ is not divisible by 7.\"\n}\n$true\n})]\n[int]\n$LuckyNumber\n)\nprocess {\n# We know LuckyNumber passed all three constraints already, so no further testing is needed.\n$LuckyNumber\n}\n}\nDo-Something -LuckyNumber 13\n&lt;#\n    Do-Something : Cannot validate argument on parameter 'LuckyNumber'. The number 13 is not divisible by 7.\n    At line:1 char:32\n    +     Do-Something -LuckyNumber 13\n    +                                ~~\n        + CategoryInfo          : InvalidData: (:) [Do-Something], ParameterBindingValidationException\n        + FullyQualifiedErrorId : ParameterArgumentValidationError,Do-Something\n#&gt;\n</code></pre> <p>Both options will result with the function throwing an error, and the error messages both provide information about why the error occurred, but I think the error message from the function using the <code>[ValidateScript()]</code> attribute is more clear and informative. That said, I think the code looks cleaner without that scriptblock sitting up there inside the <code>param()</code> block. I'd be okay with one little messy parameter declaration, but what if I have multiple functions in my module with a LuckyNumber parameter? I don't want to copy that ugly <code>[ValidateScript()]</code> attribute and its scriptblock and use it every time. Even if I made a <code>Test-LuckyNumber</code> function and simply called that within the scriptblock, I still think it makes the code harder to read and maintain.</p>"},{"location":"blog/2023/09/09/using-custom-attributes-in-powershell/#with-validateargumentsattribute","title":"with ValidateArgumentsAttribute","text":"<p>When you have complex validation to perform, or when you might need to do it many times in many functions across your module, it might make sense to write your own argument validator by sub-classing the ValidateArgumentsAttribute class. All of PowerShell's <code>[Validate*()]</code> attributes are sub-classes of <code>System.Management.Automation.ValidateArgumentsAttribute</code>, each with their own implementation of the <code>Validate(Object, EngineIntrinsics)</code> method where values passed to the parameter get tested. And the PowerShell team made it possible for us to make our own validation attributes the same way. Here's what the class definition looks like for our custom [ValidateVisibleBy()] attribute:</p> <pre><code>using namespace System.Management.Automation\nclass ValidateDivisibleBy : ValidateArgumentsAttribute {\n[int]$Divisor\nValidateDivisibleBy([int]$divisor) {\n$this.Divisor = $divisor\n}\n[void] Validate([object]$object, [EngineIntrinsics]$intrinsics) {\nif ($object % $this.Divisor) {\n$exception = [ValidationMetadataException]::new(\"The number $object is not divisible by $($this.Divisor)\")\nthrow $exception\n}\n}\n}\n</code></pre> <p>I admit it's more complex than using <code>[ValidateScript()]</code> or simply testing the value and throwing an error inside the body of the function. But when you perform the same validation across multiple functions and/or maintain the code with other people, being able to de-duplicate and easily understand the intent of the code is well worth it. Check out how much cleaner the function looks now with our <code>[ValidateDivisibleBy()]</code> attribute:</p> <pre><code>function Do-Something {\n[CmdletBinding()]\nparam(\n[Parameter()]\n[ValidateRange(0, [int]::MaxValue)]\n[ValidateDivisibleBy(7)]\n[int]\n$LuckyNumber\n)\nprocess {\n$LuckyNumber\n}\n}\nDo-Something -LuckyNumber 13\n&lt;# Error\n    Do-Something : Cannot validate argument on parameter 'LuckyNumber'. The number 13 is not divisible by 7\n    At line:32 char:27\n    + Do-Something -LuckyNumber 13\n    +                           ~~\n        + CategoryInfo          : InvalidData: (:) [Do-Something], ParameterBindingValidationException\n        + FullyQualifiedErrorId : ParameterArgumentValidationError,Do-Something\n#&gt;\n</code></pre> <p>This attribute can now be re-used in many functions by adding a simple, declarative attribute where needed. The error messages produced as a result of passing an invalid value are clean and consistent with any other argument validation error.</p>"},{"location":"blog/2023/09/09/using-custom-attributes-in-powershell/#attributes-on-functions","title":"Attributes on functions","text":"<p>I used attributes in a somewhat unconventional way with the MilestonePSTools module to add validation on entire functions and cmdlets. PowerShell facilitates validation of individual parameters during parameter binding by automatically calling the <code>Validate(Object, EngineIntrinsics)</code> method on attributes derived from <code>ValidateArgumentsAttribute</code>, but there is no framework in place to automatically call a <code>Validate()</code> method on an attribute applied to the whole command, so I implemented it by adding a call to <code>Assert-VmsRequirementsMet</code> in the <code>begin {}</code> block of every cmdlet with a \"requirement\" to assert.</p> <p>This made sense for the MilestonePSTools project because the module wraps Milestone's SDK which includes support for features available exclusively in the top-tier product version, but it also works on the free edition which lacks many features. Some commands, like <code>Get-VmsFailoverGroup</code> will only work when used while connected to a Milestone system with the <code>RecordingServerFailover</code> feature flag.</p>"},{"location":"blog/2022/12/07/your-users-deserve-argument-completers/","title":"Your users deserve argument completers","text":""},{"location":"blog/2022/12/07/your-users-deserve-argument-completers/#introduction","title":"Introduction","text":"<p>One of the things I love about PowerShell is the focus on usability and discoverability. The PowerShell team, and the community, have invested so much into reducing friction and accelerating your workflow. Argument completers are one of the tools available to you, and you should consider adding them to your projects if you aren't doing so already.</p> <p>An argument completer is a scriptblock that you can associate with a named parameter on one or more commands using the <code>Register-ArgumentCompleter</code> cmdlet. Then, when a user types that command followed by the parameter name, the argument completer is invoked. The completer receives information about the command, parameter, the characters already entered by the user (if any), along with a hashtable with the names and values of any other parameters the user has specified so far for that command.</p> <p>With this information, you can then provide the user with a list of completions. As an example, when you type <code>Get-ChildItem -</code> and then press <code>TAB</code> or <code>CTRL+Space</code>, you will get a list of files and folders in the current directory. And if you type the first few letters of the path you want, the list of argument completions narrows down to only those paths beginning with those few letters.</p> <p>I don't think it can be overstated how much it improves the user experience and accelerates people when argument completion is implemented everywhere it makes sense. This is a feature of PowerShell that I wasn't aware of when I first started to build the MilestonePSTools module and in the last year or so I have started adding them wherever I can.</p> <p>The jury is still out on how much this is appreciated by MilestonePSTools users but even if I'm the only one who appreciates them, it's still a win because they improve my quality, enable me to work faster, and reduce frustration and fatigue.</p>"},{"location":"blog/2022/12/07/your-users-deserve-argument-completers/#introducing-get-parentprocess","title":"Introducing Get-ParentProcess","text":"<p>Let's start by defining a new function called <code>Get-ParentProcess</code> which will accept either a process name, or ID, and return a <code>[pscustomobject]</code> with the name and ID of the original process, and the name and ID of the parent process. Why? Because this would be a useful function for me so why not? \ud83d\ude01</p> <pre><code>function Get-ParentProcess {\n&lt;#\n.SYNOPSIS\n    Gets the name and ID of the parent process for the specified process.\n.DESCRIPTION\n    Gets the name and ID of the parent process for the specified process. The\n    process can be specified by object, such as by piping in the results of\n    Get-Process, or by name or ID.\n    The output is a [pscustomobject] with the name and ID of the specified\n    process and the parent process if available.\n.PARAMETER InputObject\n    Specifies a Process object such as is returned by the Get-Process cmdlet.\n.PARAMETER Name\n    Specifies one or more process names.\n.PARAMETER Id\n    Specifies one or more process IDs.\n.EXAMPLE\n    Get-ParentProcess notepad\n    Gets the parent process for all processes with the name \"notepad\".\n.EXAMPLE\n    Get-ParentProcess -Id 1234\n    Gets the parent process for the process with ID 1234.\n.EXAMPLE\n    Get-Process -Name note* | Get-ParentProcess\n    Gets the parent process for all processes having a name that starts with \"note\".\n    #&gt;\n[CmdletBinding(DefaultParameterSetName = 'Name')]\n[OutputType([pscustomobject])]\nparam(\n[Parameter(ValueFromPipeline, ParameterSetName = 'InputObject')]\n[System.Diagnostics.Process[]]\n$InputObject,\n[Parameter(ValueFromPipelineByPropertyName, ParameterSetName = 'Name', Position = 0)]\n[string[]]\n$Name,\n[Parameter(ValueFromPipelineByPropertyName, ParameterSetName = 'Id', Position = 0)]\n[int[]]\n$Id\n)\nprocess {\nswitch ($PSCmdlet.ParameterSetName) {\n'InputObject' {\n}\n'Name' {\n$InputObject = Get-Process -Name $Name\n}\n'Id' {\n$InputObject = Get-Process -Id $Id\n}\ndefault {\nthrow \"Parameter set '$_' not implemented.\"\n}\n}\nforeach ($process in $InputObject) {\n$cimProcess = Get-CimInstance -ClassName win32_process -Filter \"ProcessId = $($process.Id)\"\n$parent = Get-Process -Id $cimProcess.ParentProcessId -ErrorAction SilentlyContinue\n[pscustomobject]@{\nName       = $process.Name\nId         = $process.Id\nParentName = $parent.Name\nParentId   = $parent.Id\n}\n}\n}\n}\n</code></pre> <p>Go ahead and try this function out by copying and pasting it into a PowerShell, terminal then call it using <code>Get-ParentProcess -Id $PID</code>. It should look a bit like this...</p> <pre><code>Get-ParentProcess -Id $PID\nName          Id ParentName      ParentId\n----          -- ----------      --------\npowershell 18468 WindowsTerminal    27428\n</code></pre> <p>Now, try typing <code>Get-ParentProcess -Name</code> and press <code>TAB</code>. Chances are PowerShell will fall back to using a file path completer and you'll see something like \".\\something\", which isn't terribly useful. And you'll find the same is true with <code>Get-ParentProcess -Id</code>, even though PowerShell knows that the parameter type for <code>Id</code> is <code>[int]</code>.</p> <p>Wouldn't it be nice if the right values were automatically available to select from? Well, technically since this function accepts processes as pipeline input through the <code>InputObject</code> parameter, you can use <code>Get-Process -Name</code> and then pipe to <code>Get-ParentProcess</code>. But lets make some argument completers anyway!</p>"},{"location":"blog/2022/12/07/your-users-deserve-argument-completers/#argument-completer-for-name","title":"Argument completer for \"Name\"","text":"<p>First I'll introduce the argument completer for the <code>Name</code> parameter. I decided that the completions for this argument should be de-duplicated in case there are multiple matching processes with the same name, and that the completions should be surrounded with single quotes if the name contains any spaces.</p> <pre><code>Register-ArgumentCompleter -CommandName Get-ParentProcess -ParameterName Name -ScriptBlock {\nparam($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)\n# Trim single, or double quotes from the start/end of the word to complete.\nif ($wordToComplete -match '^[''\"]') {\n$wordToComplete = $wordToComplete.Trim($Matches.Values[0])\n}\n# Get all unique process names starting with the characters provided, if any.\nGet-Process -Name \"$wordToComplete*\" | Select-Object Name -Unique | ForEach-Object {\n# Wrap the completion in single quotes if it contains any whitespace.\nif ($_.Name -match '\\s') {\n\"'{0}'\" -f $_.Name\n} else {\n$_.Name\n}\n}\n}\n</code></pre> <p>The <code>CommandName</code> and <code>ParameterName</code> parameters and values provided to <code>Register-ArgumentCompleter</code> are self-explanatory but it's worth noting that you can specify multiple command names at once, and even use wildcards. So if you have multiple cmdlets with the same parameter names, and it makes sense to use the same completion for each of them, you only need to register the completer once.</p> <p>The scriptblock begins with a <code>param()</code> declaration with 5 arguments. If you don't include a <code>param()</code> declaration, then those arguments will be available in the <code>$args</code> automatic variable. In this relatively simple use case, we only need the value from <code>$wordToComplete</code>, but here's a quick breakdown of each argument...</p> <code>$commandName</code> <p>The full name of the command for which the completer has been invoked.</p> <code>$parameterName</code> <p>The name of the parameter for which completion is being requested. This may seem strange since you can only specify a single parameter name with <code>Register-ArgumentCompleter</code> but there's nothing stopping you from storing the scriptblock in a variable and re-using it across different commands and even different parameter names. Since the scriptblock will receive the parameter name, you could leverage that to stay \"DRY\" - as in, Don't Repeat Yourself by entering the same, or very similar code many times.</p> <code>$wordToComplete</code> <p>Either an empty string or one or more characters. If there are single or double quotes at the start and/or end of the word, they will be present in the value of this variable.</p> <code>$commandAst</code> <p>This is an \"abstract syntax tree\" which is an abstract representation of the command that the user is preparing to run, including the string content of the entire pipeline. I have not waded into the deep waters of abstract syntax trees yet, but there is great strength in being able to \"look around\" the command being typed by the user. I recommend using the debugger to step into an argument completer scriptblock sometime so you can explore this argument at runtime.</p> <code>$fakeBoundParameters</code> <p>A hashtable where the keys are the other parameters, if any, that the user has specified for the same command. If the values the completer should return might be modified by the presence or value of another parameter, this enables you to augment those results accordingly. For example, if <code>Get-ChildItem -Directory -Path</code> has been typed, it doesn't make sense for PowerShell to suggest any file names. The completions for <code>Path</code> should be exclusively directories. But there's no guarantee that when the user runs the command, any of these \"fake bound parameters\" will still be present.</p> <p>After the <code>param()</code> declaration, a short regular expression is used to check whether <code>$wordToComplete</code> begins with either a single, or a double quote. If it does, then whatever that first character is will be trimmed from both the front and end of the string. That way we don't end up searching for a process named \"'note'pad\" on accident.</p> <p>Finally, we invoke <code>Get-Process</code> with our <code>$wordToComplete</code> with a wildcard character appended on the end to find all processes that start with the characters we have so far. And if the user hasn't supplied any characters, then all processes will be a match. The <code>Select-Object Name -Unique</code> part will select the name from all the results, but only pass the same name to <code>Foreach-Object</code> once. We don't want to return 100 copies of the string \"firefox\" as argument completion suggestions - one is enough.</p> <p>All that is left is to return the matching process name(s), and inside the <code>Foreach-Object</code> scriptblock we take care to wrap the name in single quotes before returning it if the name contains any spaces. If we don't wrap those names in quotes then it will be typed for the user exactly as-is, and result in an error if they don't notice and correct it. It doesn't matter if you wrap strings with single or double quotes in this case - I choose single quotes whenever I know I won't be using string-interpolation like <code>\"Hello $Name\"</code>.</p>"},{"location":"blog/2022/12/07/your-users-deserve-argument-completers/#argument-completer-for-id","title":"Argument completer for \"Id\"","text":"<p>The argument completer for the <code>Id</code> parameter is very similar to the one for the <code>Name</code> parameter. The big difference is that we are expecting the value to be an integer, so we need to do a little validation first. On the up-side, we can simplify how we return the values in the end, because there's no need to wrap the values with quotes.</p> <pre><code>Register-ArgumentCompleter -CommandName Get-ParentProcess -ParameterName Id -ScriptBlock {\nparam($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)\n$id = $wordToComplete -as [int]\nif ($null -eq $id) {\n# The supplied value for Id is not an integer so don't return any completions.\nreturn\n}\nif ([string]::IsNullOrWhiteSpace($wordToComplete)) {\n$id = $null\n}\n# Get all processes where the Id starts with the provided number(s), or all processes if no numbers were entered yet.\n(Get-Process | Where-Object { $_.Id -match \"^$id\" }).Id\n}\n</code></pre> <p>We start by attempting to coerce the string value of <code>$wordToComplete</code> into an integer. If <code>$wordToComplete</code> is null or empty, then the value of <code>$id</code> will be zero. If it is a string like \"100\", then the value of <code>$id</code> will be an integer of that value. And if <code>$wordToComplete</code> has one or more letters or other non-numberic characters, then <code>$id</code> will be null, and we shouldn't return any completions.</p> <p>Now, we either need to get all processes in the event the user hasn't entered any digits yet, or we need to get all processes with a process ID that begins with the digits provided by the user. At this point, if the user hasn't entered any digits, the value of <code>$id</code> is actually \"0\" because a null, or empty string will be cast to an integer as the value \"0\". But we don't want process ID 0 in this case, we want all processes. So before we call <code>Get-Process</code>, we set <code>$id</code> to <code>$null</code> if <code>$wordToComplete</code> is null or whitespace.</p> <p>Finally, we can call Get-process, and then filter the results down with a short regular expression where only the processes with an ID beginning with the value of <code>$id</code> may pass.</p>"},{"location":"blog/2022/12/07/your-users-deserve-argument-completers/#the-final-result","title":"The final result","text":"<p>Here is the full cmdlet with the argument completers. Copy and paste this into your terminal and have a play with the <code>TAB</code> and <code>CTRL+Space</code> list completion. Even better - copy and paste this into VSCode, tinker with the completers, and see how it changes the user experience. Then use the debugger to step into the completer and explore the <code>$commandAst</code> argument to see how you might be able to use it in your projects.</p> <pre><code>function Get-ParentProcess {\n&lt;#\n.SYNOPSIS\n    Gets the name and ID of the parent process for the specified process.\n.DESCRIPTION\n    Gets the name and ID of the parent process for the specified process. The\n    process can be specified by object, such as by piping in the results of\n    Get-Process, or by name or ID.\n    The output is a [pscustomobject] with the name and ID of the specified\n    process and the parent process if available.\n.PARAMETER InputObject\n    Specifies a Process object such as is returned by the Get-Process cmdlet.\n.PARAMETER Name\n    Specifies one or more process names.\n.PARAMETER Id\n    Specifies one or more process IDs.\n.EXAMPLE\n    Get-ParentProcess notepad\n    Gets the parent process for all processes with the name \"notepad\".\n.EXAMPLE\n    Get-ParentProcess -Id 1234\n    Gets the parent process for the process with ID 1234.\n.EXAMPLE\n    Get-Process -Name note* | Get-ParentProcess\n    Gets the parent process for all processes having a name that starts with \"note\".\n    #&gt;\n[CmdletBinding(DefaultParameterSetName = 'Name')]\n[OutputType([pscustomobject])]\nparam(\n[Parameter(ValueFromPipeline, ParameterSetName = 'InputObject')]\n[System.Diagnostics.Process[]]\n$InputObject,\n[Parameter(ValueFromPipelineByPropertyName, ParameterSetName = 'Name', Position = 0)]\n[string[]]\n$Name,\n[Parameter(ValueFromPipelineByPropertyName, ParameterSetName = 'Id', Position = 0)]\n[int[]]\n$Id\n)\nprocess {\nswitch ($PSCmdlet.ParameterSetName) {\n'InputObject' {\n}\n'Name' {\n$InputObject = Get-Process -Name $Name\n}\n'Id' {\n$InputObject = Get-Process -Id $Id\n}\ndefault {\nthrow \"Parameter set '$_' not implemented.\"\n}\n}\nforeach ($process in $InputObject) {\n$cimProcess = Get-CimInstance -ClassName win32_process -Filter \"ProcessId = $($process.Id)\"\n$parent = Get-Process -Id $cimProcess.ParentProcessId -ErrorAction SilentlyContinue\n[pscustomobject]@{\nName       = $process.Name\nId         = $process.Id\nParentName = $parent.Name\nParentId   = $parent.Id\n}\n}\n}\n}\nRegister-ArgumentCompleter -CommandName Get-ParentProcess -ParameterName Name -ScriptBlock {\nparam($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)\n# Trim single, or double quotes from the start/end of the word to complete.\nif ($wordToComplete -match '^[''\"]') {\n$wordToComplete = $wordToComplete.Trim($Matches.Values[0])\n}\n# Get all unique process names starting with the characters provided, if any.\nGet-Process -Name \"$wordToComplete*\" | Select-Object Name -Unique | ForEach-Object {\n# Wrap the completion in single quotes if it contains any whitespace.\nif ($_.Name -match '\\s') {\n\"'{0}'\" -f $_.Name\n} else {\n$_.Name\n}\n}\n}\nRegister-ArgumentCompleter -CommandName Get-ParentProcess -ParameterName Id -ScriptBlock {\nparam($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)\n$id = $wordToComplete -as [int]\nif ($null -eq $id) {\n# The supplied value for Id is not an integer so don't return any completions.\nreturn\n}\nif ([string]::IsNullOrWhiteSpace($wordToComplete)) {\n$id = $null\n}\n# Get all processes where the Id starts with the provided number(s), or all processes if no numbers were entered yet.\n(Get-Process | Where-Object { $_.Id -match \"^$id\" }).Id\n}\n</code></pre>"},{"location":"blog/2022/12/21/argument-transformation-attributes/","title":"Argument Transformation Attributes","text":""},{"location":"blog/2022/12/21/argument-transformation-attributes/#introduction","title":"Introduction","text":"<p>Argument transformation attributes make it possible to offer your users some flexibility in how they supply values for parameters. I've started to use these in the MilestonePSTools module to make it possible to provide a name instead of a strongly typed object like a <code>[RecordingServer]</code> or a <code>[Role]</code>, while still making it clear in the <code>Get-Help</code> documentation what the expected object type is, and without polluting functions with object transformation code.</p> <p>In my last post I introduced argument completers, and I consider these an absolute necessity for PowerShell functions and modules that will be shared and used by many people. Argument transformation attributes on the other hand are an advanced feature that can look intimidating to those early in their PowerShell journey. They are, in my opinion, syntactic sugar and thus purely optional.</p>"},{"location":"blog/2022/12/21/argument-transformation-attributes/#example-use-case","title":"Example use case","text":"<p>It has been almost 4 years since the first release of he MilestonePSTools module. In that time, one common question has been about <code>ParameterBindingException</code> errors. For example, if you wanted to get all hardware (cameras) from a recording server, you might try <code>Get-VmsHardware -RecordingServer 'Docker Recorder'</code> which seems perfectly reasonable. But you'd be met with the following error...</p> <pre><code>Cannot bind parameter 'RecordingServer'. Cannot convert the \"Docker Recorder\" value of type \"System.String\" to type \"VideoOS.Platform.ConfigurationItems.RecordingServer\".\n</code></pre> <p></p> <p>The <code>Get-VmsHardware</code> function expects a recording server object instead of a recording server name. The correct usage would then look like...</p> <pre><code>$recorder = Get-VmsRecordingServer -Name 'Docker Recorder'\n# Pipe the recording server in to Get-VmsHardware\n$recorder | Get-VmsHardware\n# Or provide it as a named parameter\nGet-VmsHardware -RecordingServer $recorder\n</code></pre> <p>By introducing an argument transformation attribute, we can make the <code>Get-VmsHardware</code> function accept either a recording server object, or a recording server name, without changing the parameter type or any of the code within the <code>begin</code>, <code>process</code>, or <code>end</code> blocks.</p>"},{"location":"blog/2022/12/21/argument-transformation-attributes/#writing-an-argument-transformation-attribute","title":"Writing an argument transformation attribute","text":"<p>An argument transformation attribute must be written as a class and inherit from the <code>System.Management.Automation.ArgumentTransformationAttribute</code> class. Your class must then override the <code>Transform(EngineIntrinsics, Object)</code> abstract method which is where the code that performs the object transformation will go.</p> <p>Below you will find my <code>RecorderNameTransformAttribute</code> implementation. I only want it to transform strings into recording server objects. If the value provided by the user is <code>$null</code> or is not a string, then the object will be returned as-is. I could do additional checking during the argument transformation, but PowerShell's own parameter binding and handling of null or invalid types is already so good. Why reinvent the wheel?</p> <pre><code>class RecorderNameTransformAttribute : System.Management.Automation.ArgumentTransformationAttribute {\n## Override the abstract method \"Transform\". This is where the user\n## provided value will be inspected and transformed if possible.\n[object] Transform([System.Management.Automation.EngineIntrinsics]$engineIntrinsics, [object] $inputData) {\n## Index recording servers in a hashtable by name so that we can look\n## them up by name quickly later, without multiple enumerations.\n$recorders = @{}\nGet-VmsRecordingServer | Foreach-Object {\n$recorders[$_.Name] = $_\n}\n# $inputData could be a single object or an array, and each element\n# could be $null, or any other type. The only thing we are interested\n# in are strings. We'll return everything else unaltered and let\n# PowerShell throw an error if necessary.\nreturn ($inputData | Foreach-Object {\n$obj = $_\nif ($obj -is [string]) {\nif ($recorders.ContainsKey($obj)) {\n$obj = $recorders[$obj]\n} else {\nthrow [VideoOS.Platform.PathNotFoundMIPException]::new('Recording server \"{0}\" not found.' -f $_)\n}\n}\n$obj\n})\n}\n[string] ToString() {\nreturn '[RecorderNameTransformAttribute()]'\n}\n}\n</code></pre>"},{"location":"blog/2022/12/21/argument-transformation-attributes/#using-the-argument-transform-in-get-vmshardware","title":"Using the argument transform in Get-VmsHardware","text":"<p>Once the argument transformation attribute class has been defined, it can be used in any cmdlet or function in your script or module by adding <code>[RecorderNameTransformAttribute()]</code> (or whatever you decide to call your custom attribute) between <code>[Parameter()]</code> and the parameter name. In the definition of <code>Get-VmsHardware</code> below, the highlighted line was the only change required for the function to accept recording servers by name.</p> <pre><code>function Get-VmsHardware {\n[CmdletBinding(DefaultParameterSetName = 'RecordingServer')]\nparam(\n[Parameter(ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'RecordingServer')]\n[RecorderNameTransformAttribute()] # (1)!\n[ValidateNotNull()]# (2)!\n[VideoOS.Platform.ConfigurationItems.RecordingServer[]]\n$RecordingServer,\n[Parameter(Position = 0, Mandatory, ParameterSetName = 'Id')]\n[Alias('HardwareId')]\n[guid[]]\n$Id\n)\nprocess {\nswitch ($PSCmdlet.ParameterSetName) {\n'RecordingServer' {\nif (-not $MyInvocation.BoundParameters.ContainsKey('RecordingServer')) {\nGet-VmsRecordingServer | Get-VmsHardware\n} else {\n$RecordingServer | Foreach-Object {\n$_.HardwareFolder.Hardwares\n}\n}\n}\n'Id' {\n$serverId = (Get-Site).FQID.ServerId\n$Id | ForEach-Object {\n[VideoOS.Platform.ConfigurationItems.Hardware]::new($serverId, 'Hardware[{0}]' -f $_)\n}\n}\ndefault {\nthrow \"ParameterSetName '$_' not implemented.\"\n}\n}\n}\n}\n</code></pre> <ol> <li>This attribute is the only change required to the <code>Get-VmsHardware</code>    function to enable it to accept recording server names in addition to    <code>[RecordingServer]</code> objects.</li> <li>By adding this attribute we can be sure that all elements in <code>$RecordingServer</code>    have a value and are not <code>$null</code> inside the <code>process {}</code> block.</li> </ol>"},{"location":"blog/2022/12/21/argument-transformation-attributes/#adding-an-argument-completer","title":"Adding an argument completer","text":"<p>While I hold the opinion that argument transformation attributes are nearly always \"extra\" and not required, now that it's been implemented for <code>Get-VmsHardware</code> we should probably make it easy to take advantage of using an argument completer.</p> <p>By adding the argument completer below to the class and function definitions below, the user will be able to tab or list-complete values for the <code>-RecordingServer</code> parameter, making it not only possible to provide a name instead of an object, but easy!</p> <pre><code>Register-ArgumentCompleter -CommandName Get-VmsHardware -ParameterName RecordingServer -ScriptBlock {\nparam($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)\n# Trim single, or double quotes from the start/end of the word to complete.\nif ($wordToComplete -match '^[''\"]') {\n$wordToComplete = $wordToComplete.Trim($Matches.Values[0])\n}\n# Get all unique recorder names starting with the characters provided, if any.\n$escapedWordToComplete = [System.Text.RegularExpressions.Regex]::Escape($wordToComplete)\nGet-VmsRecordingServer | Where-Object Name -match \"^$escapedWordToComplete\" | Select-Object Name -Unique | ForEach-Object {\n# Wrap the completion in single quotes if it contains any whitespace.\nif ($_.Name -match '\\s') {\n\"'{0}'\" -f $_.Name\n} else {\n$_.Name\n}\n}\n}\n</code></pre> <p></p>"},{"location":"blog/2022/12/21/argument-transformation-attributes/#the-final-result","title":"The final result","text":"<p>We can now put the three code blocks above together and use it! It's important to note though that when you're working with PowerShell classes like the <code>RecorderNameTransformAttribute</code> class in this example, we can't reference the class before defining the class.</p> <p>What I mean by this is that we can't add the <code>[RecorderNameTransformAttribute()]</code> attribute to a function parameter if the class definition appears somewhere after, or below the <code>Get-VmsHardware</code> function definition. So if you copy &amp; paste the script below as-is, it will work just fine. But if you move the class definition down under the function, PowerShell will complain that it doesn't recognize the <code>RecorderNameTransformAttribute</code> class when it attempts to process the <code>[RecorderNameTransformAttribute()]</code> attribute.</p> <p>When you use classes in a module, it's important to dot source the file(s) where your class(es) are defined before you dot source your functions. And if you have everything in a single .PSM1 file, put your classes at the top of the file so that they are always available when used in your functions.</p> <p>The argument completer on the other hand can be defined anywhere, any time, because PowerShell doesn't attempt to invoke the argument completer script block until you have typed the associated command and parameter.</p> <pre><code>class RecorderNameTransformAttribute : System.Management.Automation.ArgumentTransformationAttribute {\n## Override the abstract method \"Transform\". This is where the user\n## provided value will be inspected and transformed if possible.\n[object] Transform([System.Management.Automation.EngineIntrinsics]$engineIntrinsics, [object] $inputData) {\n## Index recording servers in a hashtable by name so that we can look\n## them up by name quickly later, without multiple enumerations.\n$recorders = @{}\nGet-VmsRecordingServer | Foreach-Object {\n$recorders[$_.Name] = $_\n}\n# $inputData could be a single object or an array, and each element\n# could be $null, or any other type. The only thing we are interested\n# in are strings. We'll return everything else unaltered and let\n# PowerShell throw an error if necessary.\nreturn ($inputData | Foreach-Object {\n$obj = $_\nif ($obj -is [string]) {\nif ($recorders.ContainsKey($obj)) {\n$obj = $recorders[$obj]\n} else {\nthrow [VideoOS.Platform.PathNotFoundMIPException]::new('Recording server \"{0}\" not found.' -f $_)\n}\n}\n$obj\n})\n}\n[string] ToString() {\nreturn '[RecorderNameTransformAttribute()]'\n}\n}\nfunction Get-VmsHardware {\n[CmdletBinding(DefaultParameterSetName = 'RecordingServer')]\nparam(\n[Parameter(ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'RecordingServer')]\n[RecorderNameTransformAttribute()] # (1)!\n[ValidateNotNull()]# (2)!\n[VideoOS.Platform.ConfigurationItems.RecordingServer[]]\n$RecordingServer,\n[Parameter(Position = 0, Mandatory, ParameterSetName = 'Id')]\n[Alias('HardwareId')]\n[guid[]]\n$Id\n)\nprocess {\nswitch ($PSCmdlet.ParameterSetName) {\n'RecordingServer' {\nif (-not $MyInvocation.BoundParameters.ContainsKey('RecordingServer')) {\nGet-VmsRecordingServer | Get-VmsHardware\n} else {\n$RecordingServer | Foreach-Object {\n$_.HardwareFolder.Hardwares\n}\n}\n}\n'Id' {\n$serverId = (Get-Site).FQID.ServerId\n$Id | ForEach-Object {\n[VideoOS.Platform.ConfigurationItems.Hardware]::new($serverId, 'Hardware[{0}]' -f $_)\n}\n}\ndefault {\nthrow \"ParameterSetName '$_' not implemented.\"\n}\n}\n}\n}\nRegister-ArgumentCompleter -CommandName Get-VmsHardware -ParameterName RecordingServer -ScriptBlock {\nparam($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)\n# Trim single, or double quotes from the start/end of the word to complete.\nif ($wordToComplete -match '^[''\"]') {\n$wordToComplete = $wordToComplete.Trim($Matches.Values[0])\n}\n# Get all unique recorder names starting with the characters provided, if any.\n$escapedWordToComplete = [System.Text.RegularExpressions.Regex]::Escape($wordToComplete)\nGet-VmsRecordingServer | Where-Object Name -match \"^$escapedWordToComplete\" | Select-Object Name -Unique | ForEach-Object {\n# Wrap the completion in single quotes if it contains any whitespace.\nif ($_.Name -match '\\s') {\n\"'{0}'\" -f $_.Name\n} else {\n$_.Name\n}\n}\n}\n</code></pre> <ol> <li>This attribute is the only change required to the <code>Get-VmsHardware</code>    function to enable it to accept recording server names in addition to    <code>[RecordingServer]</code> objects.</li> <li>By adding this attribute we can be sure that all elements in <code>$RecordingServer</code>    have a value and are not <code>$null</code> inside the <code>process {}</code> block.</li> </ol>"},{"location":"blog/2023/10/02/generate-markdown-tables-from-powershell/","title":"Generate markdown tables from PowerShell","text":"<p>I had a need to generate a markdown table dynamically from PowerShell, so I wrote a flexible function which uses the properties on the incoming objects to define the column names, supports the definition of maximum column widths, and outputs either pretty-printed markdown with padded values and aligned columns, or \"compressed\" markdown without the unnecessary padding included.</p> <p>As an alternative when working an mkdocs project, you can use the table-reader plugin to reference a CSV file in markdown. I tested this out successfully and it's a really handy tool, but in the end I wanted a method of generating a markdown table that did not depend on the use of mkdocs or python.</p> <p>Download </p> <pre><code>function ConvertTo-MarkdownTable {\n&lt;#\n.SYNOPSIS\n    Converts a collection of objects into a markdown-formatted table.\n.DESCRIPTION\n    The `ConvertTo-MarkdownTable` function converts a collection of objects into a markdown-formatted table. The names\n    of all properties on the first object are used as column names in the order they are defined. If subsequent objects\n    define properties that were not present on the first item processed, those additional properties will be ignored\n    and columns will not be created for them.\n    Optionally, a maximum width can be specified for one, or all columns using MaxColumnWidth. However, if the length\n    of the name column header is greater than the specified MaxColumnWidth, the MaxColumnWidth value used for that\n    column will be the length of the column header. Rows with column values longer than MaxColumnWidth will be truncated\n    and the Ellipsis string will be appended to the end with the length of the resulting string, plus ellipsis characters,\n    equaling the MaxColumnWidth value for that column.\n    By default, all columns will be padded with a space between any column header or value and the \"|\" characters on\n    either side. Values shorter than the longest value in the column will be right-padded so that all \"|\" characters\n    align vertically throughout the table.\n    If the additional white space is not desired, use of the `Compress` switch will omit any unnecessary white space.\n.PARAMETER InputObject\n    Specified the object, or a collection of objects to represent in the resulting markdown data table. All properties\n    of InputObject will be used to define the resulting columns. Consider using `Select-Object` first to select which\n    properties on the source object should be passed to this function.\n.PARAMETER MaxColumnWidth\n    Specifies the maximum length of all columns if one value is provided, or the maximum length of each individual column\n    if more than one value is provided. When providing more than one value, you must provide a value for every column. Columns\n    with values longer than MaxColumnWidth will be truncated, and the Ellipsis characters will be appended. The length\n    of the resulting string with ellipsis will match the MaxColumnWidth value.\n    The default value is `[int]::MaxValue` so effectively no columns will be truncated. And the minimum value is the length\n    of Ellipsis + 1, or 4 by default.\n.PARAMETER Ellipsis\n    Specifies the characters to use as an ellipsis. By default, the ellipsis value is \"...\", but this can be overridden\n    to be an empty string, or some other value. The minimum value for MaxColumnWidth is defined as 1 + the length of Ellipsis.\n.PARAMETER Compress\n    Specifies that no extra padding should be added to make the \"|\" symbols align vertically.\n.EXAMPLE\n    Get-Process | Select-Object Name, Id, VirtualMemorySize | ConvertTo-MarkdownTable -MaxColumnWidth 16\n    Gets a list of processes, selects the Name, Id, and VirtualMemorySize properties, and returns a markdown-formatted\n    table representing all properties with a maximum column width of 16 characters.\n.EXAMPLE\n    Get-Service | Select-Object DisplayName, Name, Status | ConvertTo-MarkdownTable\n    Generates a markdown-formatted table with the DisplayName, Name, and Status properties of all services.\n.EXAMPLE\n    Get-Service | Select-Object DisplayName, Name, Status | ConvertTo-MarkdownTable -Compress\n    Generates a markdown-formatted table with the DisplayName, Name, and Status properties of all services, without any\n    unnecessary padding, resulting in a much shorter string for large sets of data.\n    #&gt;#\n[CmdletBinding()]\n[OutputType([string])]\nparam(\n[Parameter(Mandatory, ValueFromPipeline, Position = 0)]\n[psobject[]]\n$InputObject,\n[Parameter()]\n[ValidateRange(1, [int]::MaxValue)]\n[int[]]\n$MaxColumnWidth = ([int]::MaxValue),\n[Parameter()]\n[string]\n$Ellipsis = '...',\n[Parameter()]\n[switch]\n$Compress\n)\nbegin {\n$MaxColumnWidth | ForEach-Object {\nif ($_ -le $Ellipsis.Length) {\nthrow \"MaxColumnWidth values must be greater than $($Ellipsis.Length) which is the length of the Ellipsis parameter. $_\"\n}\n}\n$items = [system.collections.generic.list[object]]::new()\n$columns = [ordered]@{}\n$firstRecordProcessed = $false\n}\nprocess {\nforeach ($item in $InputObject) {\n$items.Add($item)\n$columnNumber = 0\nforeach ($property in $item.PSObject.Properties) {\nif ($MaxColumnWidth.Count -gt 1 -and $MaxColumnWidth.Count -lt ($columnNumber + 1)) {\nthrow \"No MaxColumnWidth value defined for column $($columnNumber + 1). MaxColumnWidth must define a single value for all columns, or one value for each column.\"\n}\n$maxLength = $MaxColumnWidth[0]\nif ($MaxColumnWidth.Count -gt 1) {\n$maxLength = $MaxColumnWidth[$columnNumber]\n}\nif (-not $columns.Contains($property.Name)) {\nif ($firstRecordProcessed) {\nWrite-Warning \"Ignoring property '$($property.Name)' on $item because the property was not present in the first item processed.\"\ncontinue\n} else {\n$columns[$property.Name] = $property.Name.Length\nif ($property.Name.Length -gt $maxLength) {\n$maxLength = $property.Name.Length\nWrite-Warning \"The header for column $columnNumber, '$($property.Name)', is longer than the MaxColumnWidth value provided. The MaxColumnWidth value for this column is now $maxLength.\"\n}\n}\n}\n$length = 0\nif ($null -ne $property.Value) {\n$length = [math]::Min($maxLength, $property.Value.ToString().Length)\n}\nif ($columns[$property.Name] -lt $length) {\n$columns[$property.Name] = $length\n}\n$columnNumber++\n}\n$firstRecordProcessed = $true\n}\n}\nend {\nfunction Shorten {\nparam(\n[Parameter(ValueFromPipeline)]\n[string]\n$InputObject,\n[Parameter(Mandatory)]\n[ValidateRange(1, [int]::MaxValue)]\n[int]\n$MaxLength,\n[Parameter()]\n[string]\n$Ellipsis = '...'\n)\nprocess {\nif ($InputObject.Length -gt $MaxLength) {\n'{0}{1}' -f $InputObject.Substring(0, ($MaxLength - $Ellipsis.Length)), $Ellipsis\n} else {\n$InputObject\n}\n}\n}\n$sb = [text.stringbuilder]::new()\n# Header\n$paddedColumnNames = $columns.GetEnumerator() | ForEach-Object {\n$text = $_.Key | Shorten -MaxLength $_.Value -Ellipsis $Ellipsis\nif ($Compress) {\n' {0} ' -f $text\n} else {\n' {0} ' -f ($text.PadRight($_.Value))\n}\n}\n$null = $sb.AppendLine('|' + ($paddedColumnNames -join '|') + '|')\n$null = $sb.AppendLine('|' + (($paddedColumnNames | ForEach-Object { '-' * $_.Length } ) -join '|') + '|')\nforeach ($item in $items) {\n$paddedRowValues = $columns.GetEnumerator() | ForEach-Object {\n$text = [string]::Empty\nif ($null -ne $item.($_.Key)) {\n$text = $item.($_.Key) | Shorten -MaxLength $_.Value -Ellipsis $Ellipsis\n}\nif ($Compress) {\n' {0} ' -f $text\n} else {\n' {0} ' -f $text.PadRight($_.Value)\n}\n}\n$null = $sb.AppendLine('|' + ($paddedRowValues -join '|') + '|')\n}\n$sb.ToString()\n}\n}\n</code></pre>"},{"location":"blog/2022/01/07/list-milestone-xprotect-cumulative-patches/","title":"List Milestone XProtect Cumulative Patches","text":"<p>The release strategy for Milestone's XProtect VMS software is currently to drop three versions every year, with the occasional exception. The most recent release was version 2021 R2, released in October. The next version will be 2022 R1. The \"major.minor\" version numbers that will be used this year are 22.1, 22.2 and 22.3. But that only accounts for scheduled releases - what about hotfixes?</p> <p>Today, Milestone releases hotfixes on a regular basis - whenever they're needed. Due to the nature of the data recorded and managed by the XProtect VMS software, it's important to stay up to date with patches as they're made available. In this article I'll share one way you can use PowerShell to report which cumulative patches are applied. Equipped with that information, one could setup a process of automating the deployment of approved cumulative patches in their environment.</p> Example: Get-VmsHotfix<pre><code>PS C:\\&gt; Get-VmsHotfix | Select-Object DisplayName, DisplayVersion\nDisplayName                                        DisplayVersion\n-----------                                        --------------\nMilestone.Hotfix.202109202124.SCX64.21.12.7361.139 21.12.7361.139\nMilestone.Hotfix.202108250930.MC.21.12.12177.124   21.12.12177.124\n</code></pre> <p>But first, let's cover a bit of background and make sure we're on the same page about what hotfixes and patches and cumulatives are.</p>"},{"location":"blog/2022/01/07/list-milestone-xprotect-cumulative-patches/#what-is-a-hotfix","title":"What is a \"hotfix\"?","text":"<p>The term \"hotfix\" refers to a package of one or more files which usually replace the existing files of the same name. These are often DLL's (Dynamic Link Library), or EXE's (executables). DLL's and executables both contain compiled code. Often a fix for a major software bug can end up changing only one file out of hundreds, or even thousands of files that make up the whole application.</p> <p>We normally refer to a hotfix as the initial \"quick fix\" to update a system experiencing a problem of some kind. Once the hotfix is proven, it usually gets rolled into the core product. But it often makes the most sense to send customers \"patches\" to replace the small number of changed files on their existing installations versus shipping a whole new product installer. Shipping a whole product installer is more work for both the development team and the customer.</p> <p>For the first several years of my career with Milestone, we delivered hotfixes/patches as zip files containing the patched DLL's and EXE's, along with some instructions. It worked, and I had a love/hate relationship with the simplicity of it. But sometime toward the end of 2016 we started using the Milestone Patch Installer, and it was a big upgrade for our customers. They no longer had to read and follow detailed instructions on where each file needed to be. They didn't have to remember to stop the related Windows Services or applications. And Milestone's technical support team (myself included) no longer had to worry about customers applying the wrong fixes, or putting them in the wrong place on the file system.</p> <p></p>"},{"location":"blog/2022/01/07/list-milestone-xprotect-cumulative-patches/#milestone-patch-installer","title":"Milestone Patch Installer","text":"<p>The design of the patch installer uses Microsoft's Windows Installer framework to apply \"patches\". Check out Microsoft's documentation on Patching and Upgrades if you want to know more about how it works. Effectively it's the same strategy of shipping the updated DLL's, only in a much cleaner and easier to manage format. There are lots of opinions about how to ship software and updates including containerization, Chocolatey, NuGet, and I'm quite fond of the alternatives. That said, for an application installed using the Windows Installer framework, I think it makes a lot of sense to use the patching functionalty baked into that framework. And it made it significantly easier to verify if a patch had been applied or not, and to ensure it was applied correctly.</p> <p>Here's what it looks like when you have one or more Milestone cumulative patches applied. To see this list of updates, go to Control Panel &gt; Programs and Features &gt; Installed Updates.</p> <p></p> <p>Milestone's patches are typically referred to as \"Cumulative Patches\", \"Cumulative Hotfixes\" or simply \"cumulatives\". The point is, if you install the cumulative patches for an XProtect VMS 2021 R2 installation, you should expect that all fixes available at the time you downloaded the patch installer are included in that installer. Bug fixes are sometimes rolled out 2-3 times in a month, so if you missed the first two cumulatives, that's okay. Just download the latest cumulatives available for your product version and all prior fixes for your VMS version will be applied.</p> <p>The way patches are distributed today, you'll find a \"Milestone Patch Installer\" download for each Milestone component for which a patch is available. For example, here is where you can find the Milestone Patch Installer downloads for 2021 R2 today. You can see there's something available for Management Server and Recording Server, as well as a download available for MIP SDK.</p> <p></p>"},{"location":"blog/2022/01/07/list-milestone-xprotect-cumulative-patches/#what-about-automation","title":"What about automation?","text":"<p>If you have more than a handful of servers in your Milestone VMS infrastructure, you should be looking for ways to automate as much as possible with regard to the ongoing maintenance and configuration of that environment. First of all, you don't want to be wasting your time using remote access tools to open an interactive remote desktop with each and every server when you want to check which software and patches are installed.</p> <ul> <li>Silent install and uninstall (/install /quiet)</li> <li>List installed patches (registry, powershell)</li> <li>Check for latest available patches (hard)</li> </ul>"},{"location":"blog/2023/10/12/parse-code-from-markdown-files/","title":"Parse Code from Markdown Files","text":""},{"location":"blog/2023/10/12/parse-code-from-markdown-files/#introduction","title":"Introduction","text":"<p>Are you testing your documentation? If you write PowerShell scripts or modules, you are hopefully using Pester to test your code. And if you use PlatyPS to generate markdown documentation like I do, then you have a bunch of example PowerShell code sitting in .md files. But what happens if you rename a command, a parameter, or make a breaking change?</p> <p>Your documentation is the face of your product. It's the source of truth for the people who use it, whether it's a PowerShell module or something else entirely unrelated. When your examples have errors in them, it won't be obvious to everyone. Some people may copy and paste your examples, see an error, and move on. Maybe they see the use of aliases and other coding patterns that are generally not recommended to use in source code or documentation and pick up those habits, or they become unsure about the overall quality of the product behind the documentation?</p> <p>The MilestonePSTools PowerShell module I work on has 413 markdown files under the docs folder, and 394 of those files were generated by PlatyPS for commands in the module (in English and Spanish). I have a bunch of tests for the module itself, but until today I was not testing any examples or other PowerShell code blocks found in the documentation.</p>"},{"location":"blog/2023/10/12/parse-code-from-markdown-files/#oh-aliases","title":"Oh aliases...","text":"<p>My PowerShell journey started in 2019 when I began building a module. I was learning PowerShell at the same time I was building what would become a commercially used module, and learning best practices and common patterns from the community. One important best practice I failed to learn early on was use a prefix for the nouns in command names to prevent collisions with commands from other modules. So after I while, I started to add a \"Vms\" prefix to the commands in the module, and I started renaming commands and adding an alias to the new command matching the old one to help prevent breaking changes.</p> <p>The Pester test screenshot at the top of this post shows that there are some old pre-prefix commands still in use. At the time the documentation was written, these weren't aliases at all. But they are now, and people reading this documentation might be confused about the command names, or they may just naturally start using the alias version of those commands because it's in the documentation so it must be right!</p> <p></p>"},{"location":"blog/2023/10/12/parse-code-from-markdown-files/#demonstration","title":"Demonstration","text":"<p>Let's take a look at an excerpt of the docs from another command, this time in markdown format. In the first example for <code>Update-Bookmark</code>, I used the \"%\" alias in place of <code>ForEach-Object</code>. To be fair, I wanted to keep the example line from being too long. But I know there are better strategies to achieve that.</p> Update-Bookmark.md<pre><code># Update-Bookmark\n## SYNOPSIS\nUpdates the properties of a bookmark\n\n## SYNTAX\n```\nUpdate-Bookmark -Bookmark &lt;Bookmark&gt; [&lt;CommonParameters&gt;]\n```\n## DESCRIPTION\nThe `Update-Bookmark` command updates a bookmark in the VMS by pushing changes\nto the bookmark object up to the Management Server.\n\nThe expected workflow is that a bookmark is retrieved using Get-Bookmark.\nThen properties of the local bookmark object are changed as desired.\nFinally the modified local bookmark object is used to update the record on the Management Server by piping it to this cmdlet.\n\nREQUIREMENTS\n\n- Requires VMS connection and will attempt to connect automatically\n\n## EXAMPLES\n### EXAMPLE 1\n```powershell\nGet-Bookmark -Timestamp '2019-06-04 14:00:00' -Minutes 120 | % { $_.Description = 'Testing'; $_ | Update-Bookmark }\n```\nGets all bookmarks for any device where the bookmark time is between 2PM and 4PM local time on the 4th of June, changes the Description to 'Testing', and sends the updated bookmark to the Management Server.\n</code></pre> <p>The <code>Get-MdCodeBlock</code> command uses regular expressions to determine whether a line represents the beginning, or end of a code fence, and whether inline code is present in that line. If a language shortcode is used, that information is grabbed and returned with each code block. For the markdown example above, that looks like...</p> <pre><code>Get-MdCodeBlock -Path .\\Update-Bookmark.md | Select-Object Source, LineNumber, Position, Inline, Language | Format-Table\n# Source                  LineNumber Position Inline Language\n# ------                  ---------- -------- ------ --------\n# Update-Bookmark.md               9        0  False\n# Update-Bookmark.md              15        4   True\n# Update-Bookmark.md              30        0  False powershell\n</code></pre> <p>For brevity I didn't include the <code>Content</code> property in the example output above, but you can probably see the value in checking all of the example code you wrote years ago and never looked at again, despite the code base seeing dramatic changes and growth over time.</p>"},{"location":"blog/2023/10/12/parse-code-from-markdown-files/#sample-pester-test","title":"Sample Pester Test","text":"<p>Here's a basic Pester test which uses <code>Get-MdCodeBlock</code> to extract the powershell example and pass the content to <code>Invoke-ScriptAnalyzer</code>.</p> markdown.tests.ps1<pre><code>Describe 'Markdown Tests' {\nContext 'PowerShell Code Blocks are Valid' {\nBeforeDiscovery {\n. $PSScriptRoot\\Get-MdCodeBlock.ps1\n$script:codeBlocks = Get-ChildItem '*.md' | Get-MDCodeBlock -Language powershell\n}\nIt 'Analyze codeblock at &lt;_&gt;' -ForEach $script:codeBlocks {\n$analysis = Invoke-ScriptAnalyzer -ScriptDefinition $_.Content -Settings PSGallery\n$analysis | Where-Object Severity -ge 'Warning' | Out-String | Should -BeNullOrEmpty\n}\n}\n}\n</code></pre> <p>I absolutely love having this improved visibility into the health of the documentation. The tests call out the file, line number, and give me the formatted output from PSScriptAnalyzer. And you can get even more creative by using the PowerShell language parser to extract an abstract syntax tree and inspect all code hiding in markdown files for just about anything.</p> <p></p>"},{"location":"blog/2023/10/12/parse-code-from-markdown-files/#code","title":"Code","text":"<p>Download </p> <pre><code>using namespace System.Text\nusing namespace System.Text.RegularExpressions\nenum MdState {\nUndefined\nInCodeBlock\n}\nclass CodeBlock {\n[string] $Source\n[string] $Language\n[string] $Content\n[int]    $LineNumber\n[int]    $Position\n[bool]   $Inline\n[string] ToString() {\nreturn '{0}:{1}:{2}' -f $this.Source, $this.LineNumber, $this.Language\n}\n}\nfunction Get-MdCodeBlock {\n&lt;#\n.SYNOPSIS\n    Gets code from inline code and fenced code blocks in markdown files.\n.DESCRIPTION\n    Gets code from inline code and fenced code blocks in markdown files with\n    support for simple PyMdown Snippets syntax, and the PyMdown InlineHilite\n    extension which allows you to use a \"shebang\" like `#!powershell Get-ChildItem *.md -Recurse | Get-MdCodeBlock`.\n.PARAMETER Path\n    Specifies the path to the markdown file from which to extract code blocks.\n.PARAMETER BasePath\n    Specifies the base path to use when resolving relative file paths for the CodeBlock object's Source property.\n.PARAMETER Language\n    Specifies that only the codeblocks with the named language shortcode should be returned.\n.EXAMPLE\n    Get-ChildItem -Path .\\*.md -Recurse | Get-MdCodeBlock\n    Gets information about inline and fenced code from all .md files in the current directory and any subdirectories\n    recursively.\n.EXAMPLE\n    Get-MdCodeBlock -Path docs\\*.md -BasePath docs\\\n    Gets information about inline and fenced code from all .md files in the \"docs\" subdirectory. The Source property\n    on each CodeBlock object returned will be relative to the docs subdirectory.\n.EXAMPLE\n    Get-MDCodeBlock -Path docs\\*.md -BasePath docs\\ -Language powershell | ForEach-Object {\n        Invoke-ScriptAnalyzer -ScriptDefinition $_.Content\n    }\n    Gets all inline and fenced PowerShell code from all .md files in the docs\\ directory, and runs each of them through\n    PSScriptAnalyzer using `Invoke-ScriptAnalyzer`.\n.EXAMPLE\n    Get-ChildItem -Path *.md -Recurse | Get-MdCodeBlock | Where-Object Language -eq 'powershell' | ForEach-Object {\n        $tokens = $errors = $null\n        $ast = [management.automation.language.parser]::ParseInput($_.Content, [ref]$tokens, [ref]$errors)\n        [pscustomobject]@{\n            CodeBlock = $_\n            Tokens    = $tokens\n            Errors    = $errors\n            Ast       = $ast\n        }\n    }\n    Gets all inline and fenced powershell code from all markdown files in the current directory and all subdirectories,\n    and runs them through the PowerShell language parser to return a PSCustomObject with the original CodeBlock, and the\n    tokens, errors, and Abstract Syntax Tree returned by the language parser. You might use this to locate errors in\n    your documentation, or find very specific elements of PowerShell code.\n.NOTES\n    [Pymdown Snippets extension](https://facelessuser.github.io/pymdown-extensions/extensions/snippets/)\n    [Pymdown InlineHilite extension](https://facelessuser.github.io/pymdown-extensions/extensions/inlinehilite/)\n    #&gt;\n[CmdletBinding()]\n[OutputType([CodeBlock])]\nparam (\n[Parameter(Mandatory, ValueFromPipeline, Position = 0)]\n[string[]]\n[SupportsWildcards()]\n$Path,\n[Parameter()]\n[string]\n$BasePath = '.',\n[Parameter()]\n[string]\n$Language\n)\nprocess {\nforeach ($unresolved in $Path) {\nforeach ($file in (Resolve-Path -Path $unresolved).Path) {\n$file = (Resolve-Path -Path $file).Path\n$BasePath = (Resolve-Path -Path $BasePath).Path\n$escapedRoot = [regex]::Escape($BasePath)\n$relativePath = $file -replace \"$escapedRoot\\\\\", ''\n# This section imports files referenced by PyMdown snippet syntax\n# Example: --8&lt;-- \"abbreviations.md\"\n# Note: This function only supports very basic snippet syntax.\n# See https://facelessuser.github.io/pymdown-extensions/extensions/snippets/ for documentation on the Snippets PyMdown extension\n$lines = [io.file]::ReadAllLines($file, [encoding]::UTF8) | ForEach-Object {\nif ($_ -match '--8&lt;-- \"(?&lt;file&gt;[^\"]+)\"') {\n$snippetPath = Join-Path -Path $BasePath -ChildPath $Matches.file\nif (Test-Path -Path $snippetPath) {\nGet-Content -Path $snippetPath\n} else {\nWrite-Warning \"Snippet not found: $snippetPath\"\n}\n} else {\n$_\n}\n}\n$lineNumber = 0\n$code = $null\n$state = [MdState]::Undefined\n$content = [stringbuilder]::new()\nforeach ($line in $lines) {\n$lineNumber++\nswitch ($state) {\n'Undefined' {\nif ($line -match '^\\s*```(?&lt;lang&gt;\\w+)?' -and ([string]::IsNullOrWhiteSpace($Language) -or $Matches.lang -eq $Language)) {\n$state = [MdState]::InCodeBlock\n$code = [CodeBlock]@{\nSource     = $relativePath\nLanguage   = $Matches.lang\nLineNumber = $lineNumber\n}\n} elseif (($inlineMatches = [regex]::Matches($line, '(?&lt;!`)`(#!(?&lt;lang&gt;\\w+) )?(?&lt;code&gt;[^`]+)`(?!`)'))) {\nif (-not [string]::IsNullOrWhiteSpace($Language) -and $inlineMatch.Groups.lang -ne $Language) {\ncontinue\n}\nforeach ($inlineMatch in $inlineMatches) {\n[CodeBlock]@{\nSource     = $relativePath\nLanguage   = $inlineMatch.Groups.lang\nContent    = $inlineMatch.Groups.code\nLineNumber = $lineNumber\nPosition   = $inlineMatch.Index\nInline     = $true\n}\n}\n}\n}\n'InCodeBlock' {\nif ($line -match '^\\s*```') {\n$state = [MdState]::Undefined\n$code.Content = $content.ToString()\n$code\n$code = $null\n$null = $content.Clear()\n} else {\n$null = $content.AppendLine($line)\n}\n}\n}\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"blog/2022/01/04/securely-reading-passwords-from-the-console/","title":"Securely Reading Passwords from the Console","text":"<p>If you've ever written a console application which requires the user to enter sensitive information like a password or a token, you might have wrestled with concerns of exposing the password in plain text within the console window.</p> <p>I was writing a new console application earlier today after spending most of my time in PowerShell for the last three years, and I found myself wanting to use <code>Read-Host -AsSecureString</code>, and remembered how much I take for granted that PowerShell gives us so much for free.</p> <p>After making sure none of the <code>Console.Read*</code> methods baked into .NET would give me what I wanted, I wrote a fairly short <code>SecureConsole</code> class with a <code>SecureConsole.ReadLine()</code> method along with a <code>SecureConsole.GetCredential(string message)</code> method. I wanted to emulate PowerShell's <code>Get-Credential</code> since I needed both a username and password.</p> <p>Here's what I ended up with. The <code>SecureConsole.ReadLine()</code> method will...</p> <ol> <li>read any non-control character entered by the user</li> <li>append each new <code>char</code> to a <code>System.Security.SecureString</code></li> <li>write an asterisk (*) symbol back to the console</li> <li>accept the backspace key and behave as expected</li> </ol> <p></p> <p>Here's the <code>SecureConsole</code> class, and a demo program where I'm calling <code>SecureConsole.GetCredential()</code> to prompt the user for their credentials. The password will be recorded as a <code>SecureString</code> and then paired with the username to create a <code>System.Net.NetworkCredential</code>. For testing purposes, the plain text password from the credential is printed out to verify the text was received properly. Read on after the code sample for details.</p> program.cs<pre><code>using System;\nusing System.Net;\nusing System.Security;\nnamespace SecureConsoleDemo\n{\ninternal class Program\n{\nstatic void Main(string[] args)\n{\nwhile (true)\n{\nConsole.Clear();\nvar nc = SecureConsole.GetCredential();\nif (nc.UserName == String.Empty)\n{\nbreak;\n}\n// For testing purposes, your securestring password will be\n// revealed in plain text to verify it was accurately read\n// and control characters properly ignored.\nConsole.WriteLine($\"You entered '{nc.Password}'\");\nConsole.WriteLine(\"Press any key to continue. . .\");\nConsole.ReadKey(true);\n}\n}\n}\npublic static class SecureConsole\n{\npublic static NetworkCredential GetCredential()\n{\nreturn GetCredential(string.Empty);\n}\npublic static NetworkCredential GetCredential(string message)\n{\nif (!string.IsNullOrWhiteSpace(message))\n{\nConsole.WriteLine(message);\n}\nConsole.Write(\"Username: \");\nvar username = Console.ReadLine();\nConsole.Write(\"Password: \");\nvar password = SecureConsole.ReadLine();\nreturn new NetworkCredential(username, password);\n}\npublic static SecureString ReadLine()\n{\nvar password = new SecureString();\nConsoleKeyInfo key;\nwhile ((key = Console.ReadKey(true)).Key != ConsoleKey.Enter)\n{\nif (key.Key == ConsoleKey.Backspace &amp;&amp; password.Length &gt; 0)\n{\nConsole.Write(\"\\b \\b\");\npassword.RemoveAt(password.Length - 1);\n}\nelse if (!char.IsControl(key.KeyChar))\n{\nConsole.Write(\"*\");\npassword.AppendChar(key.KeyChar);\n}\n}\nConsole.Write(Environment.NewLine);\nreturn password;\n}\n}\n}\n</code></pre>"},{"location":"blog/2022/01/04/securely-reading-passwords-from-the-console/#the-main-loop","title":"The main loop","text":"<p>The program is a simple loop where we read from the console until the user enters a credential with a blank user name. Once a credential is entered, the password is printed to the screen and we do it again.</p> program.cs<pre><code>    static void Main(string[] args)\n{\nwhile (true) // (1)\n{\nConsole.Clear();\nvar nc = SecureConsole.GetCredential(); // (2)\nif (nc.UserName == String.Empty)\n{\nbreak;\n}\n// For testing purposes, your securestring password will be\n// revealed in plain text to verify it was accurately read\n// and control characters properly ignored.\nConsole.WriteLine($\"You entered '{nc.Password}'\"); // (3)\nConsole.WriteLine(\"Press any key to continue. . .\");\nConsole.ReadKey(true); // (4)\n}\n}\n</code></pre> <ol> <li>This loop will continue forever, or until we reach the <code>break;</code> on line 17 by pressing enter without entering a username.</li> <li>The <code>GetCredential()</code> method is called here without a message, and it returns a <code>System.Net.NetworkCredential</code> object.</li> <li>This is a just a sample, and for testing purposes we print the <code>Password</code> property of the network credential we received. This statement uses string interpolation.</li> <li>We call <code>Console.ReadKey()</code> with the boolean <code>true</code> to indicate that the key should be suppressed from the console.</li> </ol>"},{"location":"blog/2022/01/04/securely-reading-passwords-from-the-console/#the-getcredential-methods","title":"The GetCredential() methods","text":"<p>At the top of the <code>SecureConsole</code> class are the <code>GetCredential()</code> and an overload <code>GetCredential(message)</code> which optionally prints the specified message to the user before presenting the \"Username\" and \"Password\" fields.</p> program.cs<pre><code>  public static class SecureConsole\n{\npublic static NetworkCredential GetCredential()\n{\nreturn GetCredential(string.Empty); // (1)\n}\npublic static NetworkCredential GetCredential(string message)\n{\nif (!string.IsNullOrWhiteSpace(message)) // (2)\n{\nConsole.WriteLine(message);\n}\nConsole.Write(\"Username: \");\nvar username = Console.ReadLine();\nConsole.Write(\"Password: \");\nvar password = SecureConsole.ReadLine(); // (3)\nreturn new NetworkCredential(username, password);\n}\n</code></pre> <ol> <li>In the first overload of the <code>GetCredential()</code> method, we call the second overload with an empty message.</li> <li>In the second overload of <code>GetCredential()</code>, we print the message to the console if one was provided.</li> <li>Then we collect the plain text username and a <code>System.Security.SecureString</code> password before returning the pair in a new <code>System.Net.NetworkCredential</code>.</li> </ol>"},{"location":"blog/2022/01/04/securely-reading-passwords-from-the-console/#secureconsolereadline","title":"SecureConsole.ReadLine()","text":"<p>Finally, the <code>SecureConsole.ReadLine()</code> method. It's similar to <code>Console.ReadLine()</code> in behavior as accepts console input until a carriage return is received. The difference is that the character will not be written to the terminal, it gets stored one character at a time into an encrypted <code>SecureString</code>, and an asterisk will be written to the console so the user recognizes that the character has been received.</p> program.cs<pre><code>public static SecureString ReadLine()\n{\nvar password = new SecureString();\nConsoleKeyInfo key;\nwhile ((key = Console.ReadKey(true)).Key != ConsoleKey.Enter) // (1)\n{\nif (key.Key == ConsoleKey.Backspace &amp;&amp; password.Length &gt; 0) // (2)\n{\nConsole.Write(\"\\b \\b\");\npassword.RemoveAt(password.Length - 1);\n}\nelse if (!char.IsControl(key.KeyChar)) // (3)\n{\nConsole.Write(\"*\");\npassword.AppendChar(key.KeyChar);\n}\n}\nConsole.Write(Environment.NewLine); // (4)\nreturn password;\n}\n}\n}\n</code></pre> <ol> <li>This <code>while</code> loop uses <code>Console.ReadKey(true)</code> to receive a keypress from the console, and as long as it isn't an Enter key, the loop executes.</li> <li>Next we check to see if the key was the <code>ConsoleKey.Backspace</code>. If so, we write two <code>\\b</code> backspace characters to the terminal on either side of a \"space\" character. This effectively types \"backspace - space - backspace\" into the console to erase the last asterisk.</li> <li>If the key wasn't a backspace, and the key is also not a control character like CTRL or HOME, then an asterisk is written to the console, and we append the character to the SecureString defined on line 54.</li> <li>We're now out of the <code>while</code> loop, but the last Enter keypress was suppressed from the console, so we use <code>Console.Write(Environment.NewLine)</code> to move the console cursor to the start of the next line before returning the completed <code>SecureString</code>.</li> </ol>"},{"location":"blog/2022/01/04/securely-reading-passwords-from-the-console/#final-thoughts","title":"Final thoughts","text":"<p>There are probably more secure and complex ways to protect user input in a console app and thwart shoulder-surfing ne'er-do-wells, but this method seemed like a solid, lightweight alternative to showing passwords in plain text and storing them in simple strings. I wonder if there's a way to do it where we don't keep an unprotected <code>char</code> in memory? Let me know if there's a simpler, and/or more secure method to accomplish the same thing within the scope of a console application!</p>"},{"location":"blog/archive/2023/","title":"2023","text":""},{"location":"blog/archive/2022/","title":"2022","text":""},{"location":"blog/category/powershell/","title":"PowerShell","text":""},{"location":"blog/category/markdown/","title":"Markdown","text":""},{"location":"blog/category/usability/","title":"Usability","text":""},{"location":"blog/category/c/","title":"C#","text":""}]}